import numpy as np

# shape方法,查看数组的形状
t1 = np.arange(12)
print(t1)
print(t1.shape)  # (12,) # 如果元祖里只有一个数,那么shape表示的就是一共有的个数,一维数组

t2 = np.array([[1, 2, 3], [4, 5, 6]])
print(t2.shape)  # (2, 3) # shape 第一个数字表示的是行数,第二个表示列数,二维数组

t3 = np.array([[[1, 2, 3], [4, 5, 6]], [[7, 8, 9], [10, 11, 12]]])
print(t3)
print(t3.shape)  # (2, 2, 3) ==> 三维数字数组

# reshape 修改数组的形状
t4 = np.arange(12)
print(t4.reshape((3, 4)))  # 将这个数组变成3行,4列的数组,3*4刚好=12,要是reshape((3,5)) 就会报错
"""
[[ 0  1  2  3]
 [ 4  5  6  7]
 [ 8  9 10 11]]
"""

t5 = np.arange(24).reshape((2, 3, 4))  # 这里生成2块数组,每块里面有3行以及4列
print(t5)
"""
[[[ 0  1  2  3]
  [ 4  5  6  7]
  [ 8  9 10 11]]

 [[12 13 14 15]
  [16 17 18 19]
  [20 21 22 23]]]
"""

t5.reshape((4, 6))  # 将三维数,修改成二维,reshape是有return返回值的,所以不会修改 t5 数据本身

t5 = t5.reshape((4, 6))  # 如果结果是个None值,那么就叫做原地修改=对数据本身进行修改没有返回值

# 如果想变成一维的数组
print(t5.reshape((24,)))
# [ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23]

# 在不清楚这个数组里有几个数的时候,将这个数组变成一维的
# 查看这个数组有多少个个数 shape[0]是行数,shape[1]是列数,所以行数*列数就是数据个数
t6 = t5.reshape((t5.shape[0]*t5.shape[1],))
print(t6)

# 另一个转化一维数组的方法 flatten 方法
print(t5.flatten())  # 可以将一个多维的数组按照他的行进行展开

# =======================================================================================

# 数组的计算,数组跟数字的计算
# 当一个数组和一个数字进行计算的时候,会对数组里的所有数据进行分别计算,也就是numpy的广播原则

print(t5+2)
"""
[[ 2  3  4  5  6  7]
 [ 8  9 10 11 12 13]
 [14 15 16 17 18 19]
 [20 21 22 23 24 25]]"""

print(t5/2)

print(t5/0)
"""
[[nan inf inf inf inf inf]
 [inf inf inf inf inf inf]
 [inf inf inf inf inf inf]
 [inf inf inf inf inf inf]]"""
# nan ==> not a number, inf ==> infinite


# 数组跟数组进行计算
t6 = np.arange(100, 124).reshape((4, 6))

print(t6+t5)
"""
[[100 102 104 106 108 110]
 [112 114 116 118 120 122]
 [124 126 128 130 132 134]
 [136 138 140 142 144 146]]"""
# 在两个数组的形状是一样的时候,对应位置的数字进行计算

t7 = np.arange(0, 6)
print(t7)  # [0 1 2 3 4 5]

print(t5-t7)
"""
[[ 0  0  0  0  0  0]
 [ 6  6  6  6  6  6]
 [12 12 12 12 12 12]
 [18 18 18 18 18 18]]"""
# t7 跟 t5 纬度相同的进行计算,所以t5的每一行都会跟t7进行计算,因为t5的每一行是跟t7的形状是一样的

t8 = np.arange(4).reshape(4, 1)
print(t8)
"""
[[0]
 [1]
 [2]
 [3]]"""

print(t5-t8)
"""
[[ 0  1  2  3  4  5]
 [ 5  6  7  8  9 10]
 [10 11 12 13 14 15]
 [15 16 17 18 19 20]]"""
# 这里每一列的形状跟t5的是一样的所以可以进行计算
# 所以两个数组的纬度不一样的时候是可以进行计算的

# 当纬度跟数组形状都不一样的时候==>会报错,没办法进行计算
t9 = np.arange(10)
print(t9)  # [0 1 2 3 4 5 6 7 8 9]
# print(t5-t9) # 报错


"""广播原则: 如果两个数组的trailing dimension,既从末尾开始算起的纬度的轴长度相符或其中一方的长度为1,则认为它们是广播兼容的.
广播会在缺失和(或)长度为1的纬度上进行,比如:shape(3,3,2)可以和shape(3,2)进行计算,所以从后面开始算起,如果有一个形状是一样的就可以进行计算(3,2)=(3,2).
还有比如:shape(3,3,3)和shape(3,2)就没办法算,因为列数不相同,也就是形状不同.
同时两个数组还具备从上往下的计算比如shape(3,3,3)可以和shape(3,3,2)进行计算,因为在某一面上的形状是肯定一样的(可以想象或者画一个立方体来理解)"""
